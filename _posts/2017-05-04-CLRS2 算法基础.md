---
layout: post
title: CLRS2 算法基础
date: 2017-05-04
tag: 算法
---   

## 介绍

   这是算法导论的第二章~

### 2.1 插入排序

* **INSERTION-SORT(A)**

```
for j = 2 to A.length
	key = A[j]
	i = j - 1
	while i > 0 and A[i] > key
		A[i+1] = A[i]
		i = i - 1
	A[i + 1] = key

正确性：
	循环不变式：在for循环每次迭代的开始，A[1..j-1]已排好序。
	初始化：当j=2，显然成立。
	保持：将A[j]插入合适位置，故迭代完后保持。
	终止：终止时，j=n+1,即A[1..n]已排好序。
```

* **练习2.1-1** Using Figure 2.2 as a model, illustrate the operation of INSERTION-SORT on the array A = [31, 41, 59, 26, 41, 58].
```
too easy!
```

* **练习2.1-2** Rewrite the INSERTION-SORT procedure to sort into nonincreasing instead of nondecreasing order.
```
for j = 2 to A.length:
	key = A[j]
	i = j - 1
	while i > 0 and A[i] < key
		A[i+1] = A[i]
		i = i - 1
	A[i + 1] = key
```

* **练习2.1-3** Consider the searching problem:
   Input: A sequence of n numbers A = [a1, a2, . . . , an] and a value v.
   Output: An index i such that v = A[i] or the special value NIL if v does not appear in A.
   Write pseudocode for linear search, which scans through the sequence, looking for v. Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties. 
```
LINEAR-SEARCH(A, v)
	i = 1
	while i <= A.length
		if A[i] == v
			return i
		i = i + 1
	return NIL

循环不变式：在while循环每次迭代的开始，A[1..i-1]不包含v。
初始化：当i=1，显然成立。
保持：若A[i]==v则会返回，故保持。
终止：终止时，i=A.length+1,故A[1..A.length]不包含v.
```

* **练习2.1-4**	Consider the problem of adding two n-bit binary integers, stored in two n-element arrays A and B. The sum of the two integers should be stored in binary form in an (n + 1)-element array C. State the problem formally and write pseudocode for adding the two integers.
```
输入：
    A和B均为整形数组，A.length == B.length == n
    A, B中任意元素均为0或1
输出：
    C为整形数组，C.length == n + 1
    C中任意元素均为0或1

ADD-BINARY(A, B)
    n = length(A)
    C = Array[n+1]
    carry = 0
    for i = n to 1
        C[i+1] = (A[i] + B[i] + carry) % 2
        carry = (A[i] + B[i] + carry) / 2
    C[1] = carry
    return C
```
